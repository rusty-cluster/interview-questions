## Interview questions JavaScript
В то время как HTML обеспечивает структуру, а CSS определяет отображение, JavaScript делает веб-страницы *динамическими* — это язык сценариев, который поддерживают все браузеры и необходим для того, чтобы сделать веб-приложения *интерактивными*.

## Aсинхронный JS
  **JavaScript — это однопоточный язык программирования**, используемый как для клиентской, так и для серверной веб-разработки.
  Однопоточный означает, что весь код будет выполняться последовательно.
  Предположим, что если код занимает много времени, браузер зависнет на это время, чтобы дождаться его завершения и, таким образом, заблокирует дальнейшее выполнение.
  Используя *асинхронный JS*, мы можем выполнять задачи, не блокируя выполнение кода.
  Следовательно, он называется *non-blocking* (неблокирующим) JavaScript

- *Что такое callback (обратный вызов) в JavaScript?*

  <details>
  <summary markdown="span">+</summary>
  **Обратный вызов** - это функция, которая будет выполняться автоматически после того, как какая-либо другая функция будет выполнена полностью. Таким образом, некоторые люди также называют это 'Call after'(Позвонить после)
  Следовательно, обратный вызов решает проблему доступа к значению до того, как функция будет полностью выполнена
  </details>

- *Типовые вопросы js*
  * Как дебажить js
  * Watch команда
  * Aлгоритм сортировки. Cортировка пузырьком.


- *Promise*
  `promise`— это...
  `promise` all
  (какую проблему решают)

<details>
<summary markdown="span">+</summary>
  *Promise* — это объект JavaScript, который позволяет выполнять асинхронные операции.
  Он выдает значение, когда асинхронная операция завершается успешно, или выдает ошибку, если она не завершается.
  Это означает, что мы не хотим, чтобы приложение ждало ответа, полностью блокируя сайт для дальнейших действий.
  Но мы можем продолжить работу над ответом, когда он будет доступен.
_____
  Промис (promise) - это объект, который представляет собой результат асинхронной операции
  и позволяет выполнять последующие операции с этим результатом при его готовности.
  Он может находиться в трёх состояниях: ожидание (pending), выполнено (fulfilled) и отклонено (rejected).

  -  Промисы позволяют обрабатывать ошибки с помощью метода **.catch()**,
  который вызывается в случае, если промис был отклонён.

  -  Для параллельного выполнения нескольких асинхронных операций есть метод **Promise.all()**,
  который принимает массив промисов и возвращает новый промис,
  который будет выполнен, когда все промисы из массива будут выполнены.
  Если хотя бы один промис из массива будет отклонён, то вернётся отклонённый промис.
</details>

- *This*
  `this` — это ...
  `this` и стрелочные функции
  Как сконвертировать `callback` в промис

<details>
<summary markdown="span">+</summary>
  *this* — это ссылка на объект, содержащий текущую функцию.
  Значение this будет зависеть от того, где функция вызывается во время выполнения.
  (значение this основано на том, какой контекст находится в верхней части контекста выполнения)

  Cтрелочные функции, не имеют своего собственного this.
  Они наследуют его от родительского контекста или глобального. (ближайшим по иерархии контекстом)
  ```
  const test = {
    prop: 42,
    func: function() {
      return this.prop
    },
  };

  console.log(test.func())
  // Expected output: 42
  ```
  _____
  В JavaScript ключевое слово **this** используется для ссылки на объект,
  который является текущим контекстом исполнения кода.
  В разных контекстах значение **this** может отличаться.

  - В глобальном контексте **this** ссылается на глобальный объект
  (например, **window** в браузере или **global** в Node.js).

  - В функции, вызванной в контексте объекта, **this** ссылается на этот объект.

  - В обработчиках событий **this** ссылается на элемент, на котором произошло событие.

  - В arrow function значение **this** берется из окружающего кода,
  а не из вызова функции, т.е контекст **this** не меняется
</details>

- *Authentication and authorization/ аутентификация и авторизация*
  - Аутентификация
  - Авторизация
  - Когда использовать local storage, а когда cookies
  - Как устроена jwt аутентификация

<details>
<summary markdown="span">+</summary>
  - **Аутентификация** — процедура проверки подлинности. Например, проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.
    (например. необходимо ввести пароль, вы его вводите, и система соглашается, что вы настоящий пользователь, так как пароль совпал)
  - **Авторизация** — это предоставление пользователю прав на выполнение определенных действий. (например. Система предоставила вам право листать ленту и загружать фото)
  -----
  **Аутентификация** проверяет подлинность юзера (например по логину и паролю),
  а **авторизация** - что он может делать (например он админ и может редактировать
  записи других юзеров).
</details>

- *Опишите, как работает лексическая область в JavaScript*
<details>
<summary markdown="span">+</summary>
  Видимость и доступ к переменным и функциям зависят от области, в которой они объявлены.
  Эти элементы могут быть глобальными по области действия и, следовательно, доступными для всего кода, или локальными для блока кода или функции.
  Внутренние функции лексически связаны внешними функциями, что означает, что они имеют доступ к переменным, объявленным их внешними функциями.
</details>

### ООР. основные принципы ооп

- *Как бы вы определили классы в JavaScript?*

<details>
<summary markdown="span">+</summary>
  Класс — это, по сути, шаблон для инкапсулированного, многократно используемого кода, для которого может быть несколько экземпляров (называемых объектами), как и в любом объектно-ориентированном языке.
  Классы содержат данные в виде переменных и функций, выполняющих код.
  Классы объявляются либо как функции, либо с помощью ключевого слова class.
</details>

<details>
<summary markdown="span">+</summary>

</details>

### MSW (Mock Service Worker) 

- *Какие проблемы решает MSW*

<details>
<summary markdown="span">+</summary>
  **MSW (Mock Service Worker)** - это инструмент для создания мок-серверов,
  которые могут использоваться в разных средах для следующих целей:

  - Создание мок-серверов для эмуляции удаленного API
  и тестирования приложения на разных сценариях ответов от сервера.

  - Разработка приложения в условиях,
  когда удаленный API еще не готов или недоступен.

  - Тестирование новой функциональности в production-среде
  без риска повреждения реальных данных.

  - Оптимизация процесса разработки и тестирования приложения
  за счет ускорения работы с сервером.

  - Поддержка независимости от удаленного API
  и уменьшение зависимости приложения от сторонних сервисов.
</details>

- *MSW для разных окружений (development, testing and production)*

<details>
<summary markdown="span">+</summary>
  Существует несколько подходов к использованию **MSW** в разных средах:

  - В **development**-среде **MSW** может быть использован для эмуляции удаленного API.
  Это позволяет разработчикам работать над функциональностью,
  не зависящей от удаленного API, что ускоряет разработку и тестирование приложения.

  - В **testing**-среде **MSW** позволяет создавать мок-серверы,
  которые эмулируют различные ответы от удаленного API,
  что облегчает тестирование приложения на разных сценариях.

  - В **production**-среде **MSW** может быть использован
  для мокирования удаленного API в случае его недоступности
  или для тестирования новой функциональности в **production**-среде
  без риска повреждения реальных данных.
</details>
